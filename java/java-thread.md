# Java线程

标签（空格分隔）： Java

---

## 线程初识

### Java多线程的两种方式

1. 扩展java.lang.Thread类
2. 实现java.lang.Runnable接口

**不要调用Thread类或Runnable对象的run()。直接调用run()只会执行同一个线程中的任务，而不会启动新线程**

## 中断线程

早期版本的Java中有stop()可用来终止线程，现已废弃。
interrupt()可用来请求终止线程。
当对一个线程调用interrupt()时，线程的*中断状态*被置位。这是每一个线程都有的boolean标识。每个线程都应不时地检查这个标识，以判断线程是否被中断。
判断中断状态是否被置位：
```java
while(!Thread.currentThread().isInterrupted() && more work to do) {
    // do more work
}
```

**注：**若线程被阻塞（调用sleep()或wait()），就无法检测中断状态。此处会产生InterruptedException异常。

## 线程状态

* New（新创建）
* Runnable（可运行）
* Blocked（被阻塞）
* Waiting（等待）
* Timed waiting（计时等待）
* Terminated（被终止）

要确定一个线程的当前状态，可调用getState()

### 新创建线程

使用new操作符创建一个新线程，此时还没有运行线程中的代码，在线程运行前还有一些基础工作要做。

### 可运行线程

一旦调用start()，线程处于runnable状态。
一个可运行线程可能正在运行也可能没有运行，这取决于操作系统给线程提供运行的时间。一个正在运行的线程仍然处于可运行状态。
桌面及服务器操作系统使用抢占式调度，手机等小型设备一般采用协作式调用。
抢占式调度系统给每一个可运行线程一个时间片来执行任务，时间片用完，操作系统*剥夺*该线程的运行权，并给另一个线程运行资源。在选择下一个线程时，操作系统会考虑线程的**优先级**。
协作式调度系统中，一个线程只有在调用yield()或者被阻塞或等待时，线程才失去控制权。

### 被阻塞线程和等待线程

在这两种状态下，线程暂时不活动，不运行任何代码且消耗最少的资源，直到线程调度器重新激活它。

* 当一个线程视图获取一个内部的对象锁（不是java.util.concurrent库中的锁），而该锁被其他线程持有，则该线程进入*阻塞状态*。当所有其他线程释放该锁，并且线程调度器允许本线程持有它的时候，该线程将变成非阻塞状态。
* 当线程等待另一个线程通知调度器一个条件时，其自身进入*等待*状态。在调用Object.wait()或Thread.join()，或者是等待java.util.concurrent库中的Lock或Condition时，会出现这种情况。**被阻塞状态和等待状态是有很大不同的。**
* 当方法中具有超时参数，调用它们导致线程进入*计时等待*状态。此状态将一直保持到超时期满或者接到适当的通知。带有超时参数的方法有Thread.sleep()、Object.wait()、Thread.join()、Lock.tryLock()以及Condition.await()的计时版。

### 被终止的线程

线程终止有两个原因：

* 因为run()正常退出而自然死亡
* 因为一个没有捕获的异常终止了run()而意外死亡

## 线程属性

线程属性包括：线程优先级、守护线程、线程组以及处理未捕获异常的处理器。

### 线程优先级

默认情况下，一个线程集成它的父线程优先级。
可以使用setPriority()来设置线程的优先级。
在Thread类中，MIN_PRIORITY=1，MAX_PRIORITY=10， NORM_PRIORITY=5。

> static void yield();
// 导致当前执行的线程处于让步状态。若有其他的可运行线程具有至少与此线程同样高的优先级，那么这些线程将被调度。

### 守护线程

可通过
> t.setDaemon(true)
将线程转换为守护线程。

### 未捕获异常处理器

run()不能跑出任何被检测的异常。不需要任何catch子句来处理可被传播的异常。在线程死亡前，异常被传递到一个用于未捕获异常的处理器。
该处理器必须属于一个实现Thread.UncaughtExceptionHandler接口的类。该接口只有一个方法：
> void uncaughtException(Thread t, Throwable e)

**-未看懂，本节待续-**

## 同步

在大多数实际的多线程应用中，两个或两个以上的线程需要共享对同一数据的存取。如果两个线程存取相同的对象，且每一个线程都调用了一个修改该对象状态的方法，可能会产生讹误的对象。这样一个情况通常被成为*竞争条件（race condition）。*

竞争条件的问题在于操作不具有原子性。

### 锁对象





### 常用方法

1. 取得线程名称   getName()
2. 取得当前线程对象   currentThread()
3. 判断线程是否启动   isAlive()
4. 线程的强行运行   join()
5. 线程的休眠   sleep()
